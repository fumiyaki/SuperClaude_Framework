# SuperClaude行動モードガイド

## クイック確認

`/sc:`コマンドを使用してモードをテスト - タスクの複雑さに基づいて自動的にアクティブ化されます。完全なコマンドリファレンスは[コマンドガイド](commands.md)を参照してください。

## クイックリファレンス表

| モード | 目的 | 自動トリガー | 主要動作 | 最適な用途 |
|------|---------|---------------|---------------|---------------|
| **ブレインストーミング** | インタラクティブ発見 | "brainstorm"、"maybe"、曖昧なリクエスト | ソクラテス式質問、要件抽出 | 新プロジェクト計画、不明確な要件 |
| **内省** | メタ認知解析 | エラー回復、"推論を解析" | 透明な思考マーカー（🤔、🎯、💡） | デバッグ、学習、最適化 |
| **タスク管理** | 複雑な調整 | >3ステップ、>2ディレクトリ | フェーズ分解、メモリ永続化 | マルチステップ操作、プロジェクト管理 |
| **オーケストレーション** | インテリジェントツール選択 | マルチツール操作、高リソース使用 | 最適なツールルーティング、並列実行 | 複雑な解析、パフォーマンス最適化 |
| **トークン効率** | 圧縮コミュニケーション | 高コンテキスト使用、`--uc`フラグ | シンボルシステム、推定30-50%トークン削減 | リソース制約、大規模操作 |

---

## 始めるにあたって（2分間概要）

**モードは行動指示を通じてアクティブ化されます** - Claude Codeは、タスクパターンと複雑性に基づいてどのモード動作を採用するかを決定するコンテキストファイルを読み取ります。

**クイック例：**

```bash
# 自動アクティベーション例
/sc:brainstorm "モバイルアプリ"        # → ソクラテス式発見質問
/sc:implement "認証システム"           # → マルチフェーズ調整
"--uc analyze large-codebase/"       # → 圧縮シンボル出力
```

**手動フラグを使用するとき：**
- 特定の動作が必要：`--brainstorm`、`--introspect`、`--uc`
- 学習/デバッグのために自動検出をオーバーライド
- 特定の制約（メモリ、時間、明確性）に最適化

---

## モード詳細

### ブレインストーミングモード - インタラクティブ発見

**目的**：協力的発見を通じて曖昧なアイデアを構造化要件に変換。

**自動アクティベーショントリガー：**
- 曖昧なプロジェクトリクエスト："構築したい..."、"作成を考えている..."
- 探索キーワード：brainstorm、explore、discuss、figure out、not sure
- 不確実性指標："maybe"、"possibly"、"could we"
- 手動フラグ：`--brainstorm`、`--bs`

**行動変化：**
- **ソクラテス式質問**：隠れた要件を発見する探索質問
- **非前提的アプローチ**：仮定を避け、あなたが発見の方向を導く
- **協力的パートナーシップ**：指示的コンサルテーションではなく探索での協力
- **要件統合**：洞察を構造化技術仕様に変換
- **クロスセッションメモリ**：フォローアップディスカッションのために発見コンテキストを維持

**体験例：**

```
標準アプローチ："JWTトークンを使用したユーザー認証システムを構築します..."
ブレインストーミングアプローチ：
"🤔 一緒にこれを探索しましょう：
 - 認証がアプリで解決する具体的なユーザー問題は何ですか？
 - あなたのユーザーは誰で、彼らの技術的快適さレベルはどうですか？
 - 統合する既存システムやソーシャルログインはありますか？
 - どのようなセキュリティ/コンプライアンス要件がありますか？
 📝 結果：実装準備の整った詳細な認証要件仕様"
```

#### 成功基準

- [ ] 即座のソリューションの代わりに質問で応答
- [ ] ユーザーニーズ、技術制約、ビジネス目標を探索する質問
- [ ] 発見プロセス全体を通じて協力的なトーンを維持
- [ ] 結果として構造化要件または技術仕様を生成

**確認**：`/sc:brainstorm "webアプリ"`はユーザー、機能、技術について質問するはず
**テスト**：曖昧なリクエストは仮定ではなく発見質問をトリガーするはず
**チェック**：モードは同じ会話でのフォローアップ質問全体に持続するはず

**最適な組み合わせ：**
- **→ タスク管理**：要件発見 → 系統的実装計画
- **→ オーケストレーション**：要件明確化 → 実装のための最適ツール選択
- **手動オーバーライド**：「明確な」要件でも発見を強制するために`--brainstorm`を使用

---

### 内省モード - メタ認知解析

**目的**：学習最適化と透明な意思決定のための推論プロセスを公開。

**自動アクティベーショントリガー：**
- 自己解析リクエスト："私の推論を解析"、"決定を反省"
- 調査を必要とする予期しない結果によるエラー回復シナリオ
- 複数の実行可能アプローチでの複雑な問題解決
- 最適化機会のパターン認識ニーズ
- 手動フラグ：`--introspect`

**行動変化：**
- **推論透明性**：明確なマーカー（🤔、🎯、⚡、📊、💡）で思考プロセスを公開
- **決定解析**：選択ロジックを評価し代替アプローチを考慮
- **パターン認識**：継続的な動作と改善機会を特定
- **メタラーニング**：継続的フレームワーク改善のための洞察を抽出
- **フレームワークコンプライアンス**：SuperClaude原則と品質ゲートに対するアクションを検証

**体験例：**

```
標準アプローチ："このコード構造を解析して改善を提案します..."
内省的アプローチ：
"🧠 メタ解析：なぜ機能フローより構造解析を選んだのか？
 🎯 決定ロジック：クラス階層を見た → OOPパターン優位を仮定
 🔄 考慮した代替：データフロー解析が隠れた依存関係を明らかにするかも
 📊 証拠チェック：ファイルインポートは機能構成を示唆、OOPではない
 💡 学習：インポートを解析してから解析戦略を選択する必要
 ⚡ 修正：機能フロー解析アプローチに切り替え"
```

**最適な組み合わせ：**
- **→ タスク管理**：複雑なフェーズ決定に透明な推論を提供
- **任意のモード**：他のモードの操作に推論透明性レイヤーを追加
- **手動オーバーライド**：学習セッションとデバッグワークフローに`--introspect`を使用

---

### タスク管理モード - 複雑な調整

**目的**：マルチステップ操作のためのセッション永続化を伴う階層タスク組織。

**自動アクティベーショントリガー：**
- >3つの調整されたステップを必要とする操作
- 複数ファイル/ディレクトリスコープ（>2ディレクトリまたは>3ファイル）
- フェーズとチェックポイントを必要とする複雑な依存関係
- 品質改善リクエスト：polish、refine、enhance
- 手動フラグ：`--task-manage`、`--delegate`

**行動変化：**
- **階層計画**：複雑な作業をプラン → フェーズ → タスク → Todo構造に分解
- **セッション永続化**：中断を越えてプロジェクトコンテキストと進捗を維持
- **メモリ統合**：状態保存のためにwrite_memory/read_memoryを使用
- **進捗オーケストレーション**：追跡のためにTodoWriteとメモリ更新を調整
- **品質ゲート**：フェーズ間で系統的検証チェックポイントを実装

**体験例：**

```
標準アプローチ："ユーザー認証を実装します..." → 直接実装
タスク管理アプローチ：
"📋 マルチフェーズ実装計画：
 🎯 フェーズ1：セキュリティ要件解析（セッション1）
 🎯 フェーズ2：API設計 & ドキュメント（セッション2）
 🎯 フェーズ3：実装 & テスト（セッション3-4）
 🎯 フェーズ4：統合 & 検証（セッション5）
 💾 セッション永続化：コンテキストを自動的に再開
 ✓ 品質ゲート：各フェーズ遷移前の検証"
```

**最適な組み合わせ：**
- **ブレインストーミング →**：要件発見から系統的実装
- **+ オーケストレーション**：最適ツール選択でのタスク調整
- **+ 内省**：複雑なフェーズ決定への透明な推論

---

### オーケストレーションモード - インテリジェントツール選択

**目的**：インテリジェントツールルーティングと並列調整によるタスク実行の最適化。

**自動アクティベーショントリガー：**
- 洗練された調整を必要とするマルチツール操作
- パフォーマンス制約（高リソース使用量）
- 並列実行機会（>3つの独立ファイル/操作）
- 複数の有効なツールアプローチでの複雑なルーティング決定

**行動変化：**
- **インテリジェントツールルーティング**：各タスクタイプに最適なMCPサーバーとネイティブツールを選択
- **リソース認識**：システム制約と利用可能性に基づいてアプローチを適応
- **並列最適化**：同時実行のために独立操作を識別
- **調整フォーカス**：調整実行によるツール選択と使用の最適化
- **適応フォールバック**：好ましいオプションが利用できない場合にツールを優雅に切り替え

**体験例：**

```
標準アプローチ：順次ファイルごとの解析と編集
オーケストレーションアプローチ：
"🎯 マルチツール調整戦略：
 🔍 フェーズ1：Serena（セマンティック解析）+ Sequential（アーキテクチャレビュー）
 ⚡ フェーズ2：Morphllm（パターン編集）+ Magic（UIコンポーネント）
 🧪 フェーズ3：Playwright（テスト）+ Context7（ドキュメントパターン）
 🔄 並列実行：3つのツールが同時に作業"
```

**最適な組み合わせ：**
- **タスク管理 →**：複雑なマルチフェーズ計画にツール調整を提供
- **+ トークン効率**：圧縮コミュニケーションでの最適ツール選択
- **任意の複雑タスク**：実行を強化するためにインテリジェントツールルーティングを追加

---

### トークン効率モード - 圧縮コミュニケーション

**目的**：情報品質を保持しながらシンボルシステムによる推定30-50%のトークン削減を達成。

**自動アクティベーショントリガー：**
- 制限に近づく高コンテキスト使用
- リソース効率を必要とする大規模操作
- ユーザー明示フラグ：`--uc`、`--ultracompressed`
- 複数出力での複雑な解析ワークフロー

**行動変化：**
- **シンボルコミュニケーション**：ロジックフロー、ステータス、技術ドメインに視覚シンボルを使用
- **技術略語**：繰り返される技術用語のコンテキスト認識圧縮
- **構造化密度**：冗長な段落よりも箇条書き、表、簡潔なフォーマット
- **情報保持**：圧縮にもかかわらず≥95%の情報品質を維持
- **構造化フォーマット**：明確性とタスク完了のために組織化

**体験例：**

```
標準アプローチ："認証システム実装はユーザー検証関数にセキュリティ脆弱性を示しており、即座の注意が必要です..."
トークン効率アプローチ：
"🛡️ セキュリティアラート：
 auth.js:45 → user val() → critical vuln
 📊 影響：❌ token bypass possible
 ⚡ アクション：fix validation + audit ∵ high sev
 🔧 見積：2h impl + 1h test"
```

**最適な組み合わせ：**
- **任意のモード**：モード固有動作を保持しながら圧縮レイヤーを追加
- **オーケストレーション →**：圧縮ツール調整とステータス更新
- **手動オーバーライド**：コンテキスト圧迫または効率性が優先の場合に`--uc`を使用

---

### 標準モード - バランスの取れたデフォルト

**目的**：直接的な開発タスクのための明確でプロフェッショナルなコミュニケーションを提供。

**自動アクティベーショントリガー：**
- 複雑性指標のない明確で定義された簡単なタスク
- 明確な要件での単一ファイル操作
- 基本説明と標準開発ワークフロー
- 他のモードトリガーが検出されない（デフォルトフォールバック）

**行動変化：**
- **プロフェッショナルコミュニケーション**：圧縮なしの明確で簡潔な技術言語
- **適度な詳細**：ほとんどの開発タスクに適したバランスの取れた情報深度
- **標準ツール選択**：ネイティブClaude機能と基本ツールを使用
- **品質フォーカス**：複雑なオーケストレーションオーバーヘッドなしでコード品質を維持
- **レスポンシブ適応**：複雑性が増加したときに専門モードへの切り替え準備

**体験例：**

```
標準アプローチ：すべてのタスクに一貫したプロフェッショナルベースライン
"適切なエラーハンドリング付きログイン関数を実装します：

 1. ユーザー入力の検証（メール形式、パスワード要件）
 2. 安全なハッシュによるデータベース認証
 3. 適切な有効期限でJWTトークンを生成
 4. ユーザーデータでの成功応答を返す

 実装はセキュリティベストプラクティスに従い、包括的なエラーハンドリングを含みます。"
```

**最適な組み合わせ：**
- **→ 任意のモード**：他のモードが強化するベースラインとして機能
- **モード切り替え**：必要に応じて専門モードに自動エスカレート
- **明確性優先**：最適化より直接コミュニケーションが重要な場合

---

## 高度な使用

### モードの組み合わせ

**マルチモードワークフロー：**

```bash
# 発見 → 計画 → 実装
/sc:brainstorm "マイクロサービスアーキテクチャ" --task-manage
# → ブレインストーミング：要件発見
# → タスク管理：マルチフェーズ調整

# 透明性と効率性での解析
/sc:analyze legacy-system/ --introspect --uc
# → 内省：透明な推論
# → トークン効率：圧縮出力
```

### 手動モード制御

**特定の動作を強制：**
- `--brainstorm`：任意のタスクに協力的発見を強制
- `--introspect`：任意のモードに推論透明性を追加
- `--task-manage`：階層調整を有効化
- `--orchestrate`：ツール選択と並列実行を最適化
- `--uc`：効率性のためにコミュニケーションを圧縮

**オーバーライド例：**

```bash
# 「明確な」要件でブレインストーミングを強制
/sc:implement "ユーザーログイン" --brainstorm

# デバッグに推論透明性を追加
/sc:troubleshoot "APIエラー" --introspect

# 効率性のために出力を圧縮
/sc:analyze large-project/ --uc
```

## ベストプラクティス

### モード選択の最適化

**自然言語でのモード誘導：**
- **発見キーワード**："brainstorm"、"explore"、"figure out" → ブレインストーミング
- **複雑性指標**：複数ステップ/ファイル → タスク管理
- **効率性要求**："--uc"、"compress"、"efficiently" → トークン効率
- **透明性要求**："explain reasoning"、"show thinking" → 内省

**コンテキスト最適化：**

```bash
# 明確性のためのモード組み合わせ
/sc:implement complex-feature --task-manage --introspect
# → 階層計画 + 透明な推論

# 効率性のための組み合わせ
/sc:analyze large-codebase --orchestrate --uc
# → 最適ツール + 圧縮出力
```

### 長期プロジェクトパターン

**フェーズごとのモード使用：**
1. **発見フェーズ**：ブレインストーミング + 内省
2. **計画フェーズ**：タスク管理 + オーケストレーション
3. **実装フェーズ**：オーケストレーション + 標準
4. **最適化フェーズ**：内省 + トークン効率

## 関連リソース

**必須ドキュメント：**
- [コマンドガイド](commands.md) - モードをトリガーするコマンド
- [エージェントガイド](agents.md) - モード-エージェント相互作用
- [MCPサーバー](mcp-servers.md) - モード-MCP統合

**高度な使用：**
- [セッション管理](session-management.md) - モード永続化
- [例クックブック](../Reference/examples-cookbook.md) - モードワークフローパターン

## モードの習得

**1週目：自然な発見**
意識的なモード選択なしで自然なリクエストを使用。どのモードがいつアクティブ化されるかを観察。異なるアプローチのための直感を構築。

**2-3週目：パターン認識**
モードトリガーと動作を理解。特定の結果のためにリクエストを調整し始める。モード組み合わせを実験。

**月2以降：高度な調整**
複雑なワークフローのためにマルチモード戦略を設計。手動オーバーライドを効果的に使用。特定の制約とプロジェクトニーズに最適化。

**SuperClaudeの力：** 5つの専門モードが透明にあなたの作業スタイルと複雑性に適応し、すべて簡単で自然な言語リクエストを通じて。設定なし、管理なし、インテリジェントな適応だけ。