# セッション管理ガイド

SuperClaudeは、Serena MCPサーバーを通じて永続セッション管理を提供し、Claude Code会話間での真のコンテキスト保存と長期プロジェクト継続を可能にします。

## 永続メモリ付きコアセッションコマンド

### `/sc:load` - 永続メモリによるコンテキスト読み込み

**目的**：以前のセッションからのプロジェクトコンテキストと永続メモリでセッションを初期化
**MCP統合**：格納されたプロジェクトメモリを読み取るためにSerena MCPをトリガー
**構文**：`/sc:load [project_path]`

**何が起こるか**：
- Serena MCPが以前のセッションからの永続メモリファイルを読み取り
- 格納されたメモリからプロジェクトコンテキストが復元
- 以前の決定、パターン、進捗が読み込まれる
- 履歴コンテキストでセッション状態が初期化される

**使用例**：

```bash
# 永続メモリから既存のプロジェクトコンテキストを読み込み
/sc:load src/

# 完全な履歴で特定のプロジェクト作業を再開
/sc:load "authentication-system"

# コードベース解析と以前の洞察で初期化
/sc:load . --analyze
```

### `/sc:save` - メモリへのセッション永続化

**目的**：現在のセッション状態と決定を永続メモリに保存
**MCP統合**：メモリファイルを書き込むためにSerena MCPをトリガー
**構文**：`/sc:save "session_description"`

**何が起こるか**：
- 現在のコンテキストと決定がSerenaメモリに書き込まれる
- プロジェクト状態と進捗が会話間で永続化される
- 主要な洞察とパターンが将来のセッション用に格納される
- 取得用のタイムスタンプでセッション要約が作成される

**使用例**：

```bash
# 将来の参照のために完了した機能作業を保存
/sc:save "JWTでユーザー認証を実装"

# 複雑な作業中にチェックポイント
/sc:save "API設計フェーズ完了、実装準備完了"

# アーキテクチャ決定を永続的に格納
/sc:save "マイクロサービスアーキテクチャ決定、サービス境界定義"
```

### `/sc:reflect` - メモリコンテキストによる進捗評価

**目的**：格納されたメモリに対する現在の進捗を解析し、セッション完全性を検証
**MCP統合**：格納されたメモリに対して現在の状態を比較するためにSerena MCPを使用
**構文**：`/sc:reflect [--scope project|session]`

**何が起こるか**：
- Serena MCPが以前のメモリと現在のコンテキストを読み取り
- 格納された目標とマイルストーンに対して進捗が評価される
- 履歴コンテキストを使用してギャップと次のステップが特定される
- プロジェクトメモリに対してセッション完全性が検証される

**使用例**：

```bash
# 格納されたマイルストーンに対するプロジェクト進捗を評価
/sc:reflect --scope project

# 現在のセッション完全性を検証
/sc:reflect

# メモリに基づいて次のフェーズに移る準備ができているかチェック
/sc:reflect --scope session
```

## 永続メモリアーキテクチャ

### Serena MCPが真の永続化を可能にする仕組み

**メモリストレージ**：
- 構造化メモリファイルとして格納されたセッションコンテキスト
- 永続的に保存されたプロジェクト決定とアーキテクチャパターン
- 会話間で保持されたコード解析結果と洞察
- 長期間維持される進捗追跡とマイルストーンデータ

**クロスセッション継続性**：
- 新しい会話で自動的に利用可能な以前のセッションコンテキスト
- 会話間で保存されアクセス可能な決定と理論的根拠
- 過去のパターンと解決策からの学習が維持される
- 無期限に維持される一貫したプロジェクト理解

**メモリタイプ**：
- **プロジェクトメモリ**：長期的なプロジェクトコンテキストとアーキテクチャ
- **セッションメモリ**：特定の会話結果と決定
- **パターンメモリ**：再利用可能な解決策とアーキテクチャパターン
- **進捗メモリ**：マイルストーン追跡と完了ステータス

## 永続化によるセッションライフサイクルパターン

### 新プロジェクト初期化

```bash
# 1. 新しいプロジェクトを開始
/sc:brainstorm "Eコマースプラットフォーム要件"

# 2. 初期決定を永続メモリに保存
/sc:save "プロジェクトスコープと要件定義"

# 3. 実装計画を開始
/sc:workflow "ユーザー認証システム"

# 4. アーキテクチャ決定を永続的に保存
/sc:save "認証アーキテクチャ：JWT + リフレッシュトークン + レート制限"
```

### 既存作業の再開（クロス会話）

```bash
# 1. 永続メモリから以前のコンテキストを読み込み
/sc:load "e-commerce-project"

# 2. 格納された進捗に対する現在の状態を評価
/sc:reflect --scope project

# 3. 格納されたコンテキストを使用して次のフェーズを継続
/sc:implement "決済処理統合"

# 4. 進捗チェックポイントをメモリに保存
/sc:save "Stripe APIで決済システム統合"
```

### 長期プロジェクト管理

```bash
# 永続化による週次チェックポイントパターン
/sc:load project-name
/sc:reflect --scope project
# ... 機能での作業 ...
/sc:save "週N進捗：機能X、Y、Z完了"

# メモリによるフェーズ完了パターン
/sc:reflect --scope project
/sc:save "フェーズ1完了：コア認証とユーザー管理"
/sc:workflow "フェーズ2：決済と注文処理"
```

## クロス会話継続性

### 永続化による新しい会話の開始

新しいClaude Code会話を開始するとき、永続メモリシステムは以下を可能にします：

1. **自動コンテキスト復元**

   ```bash
   /sc:load project-name
   # 以前のすべてのコンテキスト、決定、進捗を自動的に復元
   ```

2. **進捗継続**
   - 以前のセッション決定が即座に利用可能
   - アーキテクチャパターンとコード洞察が保存される
   - プロジェクト履歴と理論的根拠が維持される

3. **インテリジェントコンテキスト構築**
   - Serena MCPが現在の作業に基づいて関連メモリを提供
   - 過去の解決策とパターンが新しい実装を情報提供
   - プロジェクト進化が追跡され理解される

### メモリ最適化

**効果的なメモリ使用**：
- 記述的で検索可能なメモリ名を使用
- プロジェクトフェーズとタイムスタンプコンテキストを含める
- 特定の機能やアーキテクチャ決定を参照
- 将来の取得を直感的にする

**メモリコンテンツ戦略**：
- 結果だけでなく決定と理論的根拠を格納
- 考慮した代替アプローチを含める
- 統合パターンと依存関係を文書化
- 将来の参照のために学習と洞察を保存

**メモリライフサイクル管理**：
- 古いメモリの定期的なクリーンアップ
- 関連するセッションメモリの統合
- 完了したプロジェクトフェーズのアーカイブ
- 古いアーキテクチャ決定の整理

## 永続セッションのベストプラクティス

### セッション開始プロトコル

1. 既存プロジェクトは常に`/sc:load`で始める
2. メモリから現在の状態を理解するために`/sc:reflect`を使用
3. 永続コンテキストと格納されたパターンに基づいて作業を計画
4. 以前の決定とアーキテクチャ選択の上に構築

### セッション終了プロトコル

1. 格納された目標に対する完全性を評価するために`/sc:reflect`を使用
2. 将来のセッションのために`/sc:save`で主要決定を保存
3. 次のステップと未解決の質問をメモリに文書化
4. シームレスな将来の継続のためにコンテキストを保存

### メモリ品質維持

- 簡単な取得のために明確で記述的なメモリ名を使用
- 決定と代替アプローチについてのコンテキストを含める
- 特定のコード位置とパターンを参照
- セッション間でメモリ構造の一貫性を維持

## 他のSuperClaude機能との統合

### MCPサーバー調整

- **Serena MCP**：永続メモリインフラストラクチャを提供
- **Sequential MCP**：拡張複雑解析のために格納されたメモリを使用
- **Context7 MCP**：格納されたパターンとドキュメントアプローチを参照
- **Morphllm MCP**：格納されたリファクタリングパターンを一貫して適用

### メモリによるエージェント協力

- エージェントが拡張コンテキストのために永続メモリにアクセス
- 以前の専門決定が保存され参照される
- 共有メモリを通じたクロスセッションエージェント調整
- プロジェクト履歴に基づく一貫した専門推奨

### 永続化によるコマンド統合

- すべての`/sc:`コマンドが永続コンテキストを参照し構築可能
- 以前のコマンド出力と決定がセッション間で利用可能
- ワークフローパターンが格納され再利用可能
- 実装履歴が将来のコマンド決定をガイド

## 永続セッションのトラブルシューティング

### よくある問題

**メモリが読み込まれない**：
- Serena MCPが適切に設定され実行されていることを確認
- メモリファイルの権限とアクセス可能性をチェック
- 一貫したプロジェクト命名規約を確実にする
- メモリファイルの整合性と形式を検証

**セッション間でのコンテキスト損失**：
- セッション終了前に常に`/sc:save`を使用
- 簡単な取得のために記述的なメモリ名を使用
- メモリ完全性を検証するために定期的な`/sc:reflect`
- 重要なメモリファイルを定期的にバックアップ

**メモリ競合**：
- バージョン管理のためにタイムスタンプ付きメモリ名を使用
- 古いメモリの定期的なクリーンアップ
- プロジェクトとセッションメモリの明確な分離
- セッション間での一貫したメモリ命名規約

### クイックフィックス

**セッション状態をリセット**：

```bash
/sc:load --fresh  # 以前のコンテキストなしで開始
/sc:reflect       # 現在の状態を評価
```

**メモリクリーンアップ**：

```bash
/sc:reflect --cleanup  # 古いメモリを削除
/sc:save --consolidate # 関連メモリをマージ
```

**コンテキスト回復**：

```bash
/sc:load --recent     # 最新のメモリを読み込み
/sc:reflect --repair  # コンテキストギャップを特定し修正
```

## 高度な永続セッションパターン

### マルチフェーズプロジェクト

- 組織のためにフェーズ固有のメモリ命名を使用
- フェーズ間でのアーキテクチャ決定継続性を維持
- 永続メモリを通じたクロスフェーズ依存関係追跡
- 履歴コンテキストでの段階的複雑性管理

### チーム協力

- 共有メモリ規約と命名標準
- チームコンテキストのための決定理論的根拠保存
- すべてのチームメンバーがアクセス可能な統合パターンドキュメント
- メモリを通じた一貫したコードスタイルとアーキテクチャ強制

### 長期メンテナンス

- 完了したプロジェクトのためのメモリアーカイブ戦略
- 蓄積されたメモリを通じたパターンライブラリ開発
- 時間をかけて構築された再利用可能ソリューションドキュメント
- 永続メモリ蓄積による知識ベース構築

## 永続セッション管理の主要利点

### プロジェクト継続性

- 複数の会話間でのシームレスな作業継続
- Claude Codeセッション間でのコンテキスト損失なし
- 保存されたアーキテクチャ決定と技術的理論的根拠
- 長期プロジェクト進化追跡

### 生産性向上

- プロジェクトコンテキストを再説明する必要の削減
- 継続作業のための高速スタートアップ時間
- 以前の洞察とパターンでの構築
- 累積的なプロジェクト知識成長

### 知識保持

- セッション間での学習と洞察の保存
- プロジェクト特有のパターンと解決策のライブラリ
- アーキテクチャ決定の履歴記録
- 将来のプロジェクトでの再利用可能な知識資産

## まとめ

SuperClaudeの永続セッション管理は、Serena MCPサーバーの力を通じて真のプロジェクト継続性を提供します。`/sc:load`、`/sc:save`、`/sc:reflect`コマンドにより、複雑で長期のプロジェクトを複数のClaude Code会話にわたって維持し、各セッションが以前の作業、決定、学習の完全なコンテキストで開始されることを確保できます。

この強力なメモリシステムは、個々のセッションの生産性を向上させるだけでなく、時間をかけて蓄積される知識ベースとパターンライブラリを構築し、各プロジェクトを以前のものよりも効率的で洞察に富んだものにします。